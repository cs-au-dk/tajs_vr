/*
 * Copyright 2009-2019 Aarhus University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dk.brics.tajs.preprocessing;

import dk.brics.tajs.options.Options;
import dk.brics.tajs.options.TAJSEnvironmentConfig;
import dk.brics.tajs.util.AnalysisException;
import dk.brics.tajs.util.Collectors;
import dk.brics.tajs.util.Lists;
import dk.brics.tajs.util.PathAndURLUtils;
import org.apache.log4j.Logger;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

public class Babel {

    private static final Logger log = Logger.getLogger(Babel.class);

    private static final String babelPlugins =
            Stream.of("arrow-functions", "block-scoping", "classes", "shorthand-properties", "for-of",
                      "template-literals", "parameters", "spread", "destructuring", "computed-properties")
            .map(name -> "@babel/plugin-transform-" + name).collect(java.util.stream.Collectors.joining(","));

    private static final Pattern successPattern = Pattern.compile("Successfully compiled (\\d+) files? with Babel\\.");

    private static final Set<String> supportedFileExtensions = Stream.of(".es6", ".js", ".es", ".jsx", ".mjs", "").collect(java.util.stream.Collectors.toSet());

    /**
     * This method performs babel preprocessing on the files listed in the *files* parameter.
     * It replaces the main file of the analysis with the one generated by babel.
     * If soundness testing is enabled the *onlyIncludeForInstrumentation* options will be
     * updated to point to the files generated by babel.
     *
     * The method assumes that the main file is in the set of files given, or at least in
     * the subtree of the common ancestor of the files given.
     *
     * Additional options for babel can be specified in babel.config.js in extras/babel.
     *
     * @param commonAncestor The path to the common ancestor of all files in an application.
     *                       Files output by babel will be put in a directory structure similar to the one
     *                       found in commonAncestor in a subdirectory named "_babel".
     * @param files A set of files to be processed by babel. Other files found in the directory
     *              specified by *commonAncestor* will be copied as-is.
     */
    public static void translate(Path commonAncestor, Set<Path> files) {
        List<Path> args = Options.get().getArguments();
        Path testFile = Lists.getLast(args);
        Path realCommonAncestor = PathAndURLUtils.toRealPath(commonAncestor);
        Path babelRoot = commonAncestor.resolve("_babel");
        Path babelPath = TAJSEnvironmentConfig.get().getBabel();

        /* If we run babel with the project root as input directory, it will copy all files in it! */
        if (PathAndURLUtils.getWorkingDirectory().startsWith(realCommonAncestor)) {
            throw new IllegalArgumentException(
                    "Babel: The current working directory is in the subtree of the common ancestor of the analysed files!" +
                            "\nWorking directory: " + PathAndURLUtils.getWorkingDirectory() +
                            "\nCommon ancestor: " + realCommonAncestor +
                            "\nFiles (" + files.size() + "):\n" +
                            files.stream().map(Path::toString).collect(java.util.stream.Collectors.joining("\n"))
            );
        }

        List<Path> relativeFiles = files.stream()  // Babel does not handle json files so let us filter those out
                .filter(file -> !PathAndURLUtils.getFileExtension(file).equals(".json"))
                .map(file -> realCommonAncestor.relativize(file.toAbsolutePath()))
                .distinct().collect(Collectors.toList());

        Set<String> fileExtensions = relativeFiles.stream().map(PathAndURLUtils::getFileExtension).collect(Collectors.toSet());
        fileExtensions.retainAll(supportedFileExtensions);

        List<String> baseCmd = Arrays.asList(
                babelPath.toString(),
                "--root-mode", "upward",            // Find the nearest babel.config.js in the file-system
                "--extensions", String.join(",", fileExtensions),
                "--keep-file-extension",
                "--verbose",
                "--plugins", babelPlugins,          // Plugins used for transformations
                "--out-dir", babelRoot.toString()   // Output directory
        );

        try {
            // Split list into sublists to avoid argument list length limit
            final int sublistSize = 100;
            for(int i = 0; i < relativeFiles.size(); i += sublistSize) {
                List<Path> subFiles = relativeFiles.subList(i, Math.min(i + sublistSize, relativeFiles.size()));
                ArrayList<String> cmd = new ArrayList<>(baseCmd);

                if(i == 0) { // Delete and copy other files in the first pass
                    cmd.add("--delete-dir-on-start");
                    cmd.add("--copy-files");
                }

                cmd.add("--only"); // Control which files to transform (must be absolute for babel to work correctly)
                cmd.add(subFiles.stream().map(file -> commonAncestor.resolve(file).toString()).collect(java.util.stream.Collectors.joining(",")));
                cmd.add(commonAncestor.toString()); // Input directory

                // Run the babel command
                Process process = new ProcessBuilder(cmd).directory(babelPath.getParent().toFile()).start();
                String output, err;

                try (BufferedReader stdBr = new BufferedReader(new InputStreamReader(process.getInputStream()));
                     BufferedReader errBr = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {

                    output = stdBr.lines().collect(java.util.stream.Collectors.joining("\n"));
                    err = errBr.lines().collect(java.util.stream.Collectors.joining("\n"));
                    process.waitFor();
                }

                if (process.exitValue() != 0)
                    throw new AnalysisException("Error occurred while running babel:\n" + err);

                if (!Options.get().isQuietEnabled())
                    System.out.println(output);

                Matcher m = successPattern.matcher(output);
                if (!m.find())
                    log.warn("Babel might not have run successfully!\n" + output);
                else {
                    int processedFiles = Integer.parseInt(m.group(1));
                    if (processedFiles != subFiles.size())
                        throw new AnalysisException(String.format("Babel processed %d/%d files", processedFiles, subFiles.size()));
                }
            }
        } catch (InterruptedException | IOException e) {

            throw new AnalysisException("Error occurred while running babel:\n" + e);
        }

        // Override soundness tester options with new files
        if (Options.get().getSoundnessTesterOptions().isGenerateOnlyIncludeAutomaticallyForHTMLFiles()
            || Options.get().getSoundnessTesterOptions().isGenerateOnlyIncludeAutomatically()) {

            Set<Path> babelFiles = relativeFiles.stream().map(babelRoot::resolve).collect(Collectors.toSet());
            Options.get().getSoundnessTesterOptions().setOnlyIncludesForInstrumentation(Optional.of(babelFiles));
            // rootDirFromMainFile can keep its value
        }

        // Fix the main file path
        Path babelTestFile = PathAndURLUtils.getRelativeToTAJS(
                babelRoot.resolve(realCommonAncestor.relativize(PathAndURLUtils.toRealPath(testFile)))
        ).get();

        args.set(args.size() - 1, babelTestFile);
    }
}
